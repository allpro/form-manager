= FormManager API Reference
:source-highlighter: pygments
:pygments-style: manni
:source-language: javascript
:icons: font
:toc:
:toc-placement!:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

[.small]#Last update: {localdate}#

WARNING: THIS IS A JUST AN OUTLINE -- A WORK IN PROGRESS

toc::[]


== API Overview & Conventions


*FM exposes _only_ 'methods' - no 'properties'.* +
All of FM's data caches are _private_ so they cannot
be accidentally mutated.
Data interactions are performed with getter and setter methods.
Most methods also _clone_ data in both directions to maintain immutability.

*FM's' extensive API provides control of _everything_ FM handles.* +
Anything a user can do can also be done programmatically.
You have full control of the data, as well as every _field_ FM manages.


=== Method Name Variations

Some API methods have 2 or more name variations.
These are just _aliases_ for the same method.
The API descriptions list all variations for each method.

==== Singular & Plural Aliases

Many setter & getter methods have both singular and plural names,
like `getValue()`/`getValues()`.
The `getValue()` method can return a single value _or_ all values,
so you can choose the most semantic _alias_ for your use, like:

====== _Singular vs Plural Method Names_
[source,javascript,linenums,hightlight=2..3]
----
const username = form.getValue('username')  // One value
const username = form.getValues('username') // One value
const fieldValues = form.getValue()  // All values (object)
const fieldValues = form.getValues() // All values (object)
----

==== Verbose & Abbreviated Aliases

Many methods have both verbose and abbreviated variations,
like `isFieldDisabled()` and `isDisabled()`.
The short variations aids code brevity and
the long variations provide more clarity.

Some _getter_ methods have even shorter names,
like `getValue()`/`value()` and `getDataProps()`/`dataProps()`.
This can provide even more brevity, like when using these methods repeatedly:

.Short Method Names Sample
[source,html]
----
<TextField label="First Name"  {...form.allProps("firstName")} />
<TextField label="Middle Name" {...form.allProps("middleName")} />
<TextField label="Last Name"   {...form.allProps("lastName")} />
----

=== Chaining Commands

All _setter_ methods return the FormManager object,
which allow multiple form commands to be chained, like:
[source]
----
form.setFieldRequired('phone')
form.validate('phone')
// Is the same as...
form.setFieldRequired('phone').validate('phone')
----

=== Using Fieldname Aliases

If an `aliasName` is set for a field, it can be used with _any_ FM method.
In the example below, each pair of commands shown are equivalent,
and both variations are valid.

[source,javascipt+html]
----
const formConfig = {
  fields: {
    'profile.contacts.primaryPhone': {
      aliasName: 'phone'
    }
  }
}

const phone = form.getValue('profile.contacts.primaryPhone')
const phone = form.getValue('phone')

form.setFieldDisabled('profile.contacts.primaryPhone')
form.setFieldDisabled('phone')

<TextField {...form.allProps('profile.contacts.primaryPhone')}
<TextField {...form.allProps('phone')}
----

'''

== Form Rendering Methods


update | render ::

Force a re-render of the component FM is inside
+
FM _automatically_ triggers renders when necessary.
However if you programically change form configuration,
you need to trigger a re-render for the changes to take effect.
This method provides that, and also increments the form revision value.

@params (0) :::
@returns FormManager :::
//

''''

revision | getRevision ::
  Force a re-render of the component FM is inside

@params (2) :::

  - `component` {nbsp} [.small]#{Component|string} `["div"]`# +
  The wrapper-element generated by FluidGrid.

  - `columnSpacing` {nbsp} [.small]#{integer|string} `[0]`# +
  Horizontal spacing between items +
  Value must be a valid CSS measurement, like "4px" or "1em" +
  See [Spacing and Divider Logic](#spacing-and-divider-logic)

@returns FormManager :::
//

'''


==== update | render ()

FM _automatically_ triggers renders when necessary.
However if you programically change form configuration,
you need to trigger a re-render for the changes to take effect.
This method provides that, and also increments the form revision value.

==== getRevision ()


== Configuration Methods

Every aspect of FM is controlled by the form-configuration.
Normally you provide a set of confuration options when you create a FM
instance for a form.
However all configuration is dynamic, and can be changed at any time.
The most common configuration changes have special methods to simplify things.
For example, changing field validation rules, disabling one or all fields,
changing the error-messages (eg: a different languange), etc.


==== setConfig | setFieldConfig (name, data)

==== setFieldDefaults (settings)


==== isDisabled | isFieldDisabled (name)

==== setDisabled | setFieldDisabled (name)

==== setDefaultDisabled ([disable] = true)


==== isFieldReadOnly (name)

==== setReadOnly | setFieldReadOnly (name)

==== isReadOnly (name)

==== setDefaultReadOnly ([readOnly] = true)


== Validation & Error Methods

Validation is usually handled by configuration the fields that require it,
so it is a _subset_ of configuration.
However there are cases when its useful to read, perform, or change validation
rules programatically, so there is a rich API devoted to validation rules.


==== validate (name, value, [eventName])

==== validateAll ()


==== getFieldValidation (name)

==== setFieldValidation (name, settings)

==== getFieldConfig (name)

==== isRequired | isFieldRequired (name)

==== setRequired | setFieldRequired (name)

==== errors | getError | getErrors (name)

==== setError | setErrors (name, type, [errorMessage])

==== clearError | clearErrors ([name])


== Data & Value Methods

FM _caches_ and _synchronizes_ two separate sets of data.
It is important to understand the difference when deciding which
API methods to use.

Methods containing the word "data" target the Data cache,
while those containing "value" target the Values cache.
However changes to either cache are immediately _synced_ to the other.
When you want to programically set data in a form-field,
a Value method should be used.
If you need to update the _source_ data, use a Data method.

Any change to _either_ cache will immediately update the Data cache.
If a data transformation is required, it is done on the fly.

=== 'Data' Cache

The 'Data' cache starts as a _copy_ of the data originally supplied to FM,
if any was. This cache has the same structure and fieldnames as the source.
When any 'data getter' (eg: `getData()`) is called,
the data will be returned in the source structure, ready to be posted.

FM tracks the _original_ data, so knows precisely which data has
changed since the form was initialized.
This is useful if you want to do a PATCH update.

Data tracking also allows FM to know whether the form is 'clean' or 'dirty'.
If a user changes a value, then later changes it _back_ to the original value,
FM knows that this data value is _no longer_ 'changed'.


=== 'Values' Cache

The 'Values' cache contains the values supplied to the form fields via props.
These values may be a different data-type of format than the source data,
to suit the requirements of each field-type.

*The Values cache is a single level deep.* There has no _nested keys_.
Nested structures from the 'Data' cache are flattened to become 'paths',
like `"user.profile.address.street"`.
These paths are the keys used in the Values object,
and are used as the *fieldnames* in the form...

=== Field aliasName

Instead of using long 'path-names' (eg: "user.profile.address.street"),
an '*aliasName*' can is set in a field's configuration,
like `"addressStreet"`.
All code can then _optionally_ use this alias instead of the path-name.
Using aliases is recommended to make form markup simpler.

Aliases can also be used to _normalize_ fieldnames from different datasets.
For example, if you have multiple sets of data than contain an address,
and these don't all have identical fieldnames,
then aliases can normalize them so they can use the same `<AddressForm>`
component, without needing any extra logic.


==== isClean ([name])

==== isDirty ([name])

==== reset ()


==== changes | getChanges ()

==== data | getData ([name], [options])

==== setData (nameOrData, [fieldData])



==== value | values | getValue | getValues ([name])

==== setValue | setValues (name, value)


== Form 'State' Methods


==== state | getState ([key])

==== setState (key, value)


== Form and Field Methods

ALSO SEE methods like:

 - `getValue()` in the Values section
- `getError()` in the Validation section
- `isFieldDisabled()` in the Configuration section

These methods are used to set field props,
but usually you'll use the `allProps()` or `dataProps()` helpers instead,
which _combine_ all the individual props into a single setter.


==== allProps (name)

==== dataProps (name)

==== errorProps (name)

==== cleanField | cleanFieldValue (name)

==== hasError | hasErrors (name)

==== onFieldBlur (event_or_name, [value])

==== onFieldChange (event_or_name, [value])

==== onFieldFocus (event_or_name, [value])

