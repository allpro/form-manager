= FormManager API Reference
:source-highlighter: pygments
:pygments-style: manni
:source-language: javascript
:icons: font
:table-stripes: even
:prewrap!:
:toc:
:toc-placement!:
:toclevels: 3
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

[.small]#Last update: {localdate}#

NOTE: THIS IS A WORK IN PROGRESS

[WARNING]
====
*BREAKING CHANGES* in the v7.x API: +

- `getErrors(fieldname)` => `getError(fieldname)`
- `setErrors(fieldname, errors)` => `setError(fieldname, errors)`
====

toc::[]


== API Overview & Conventions

FormManager ("*FM*") has an extensive API.
_Everything_ can be done programmatically so
you have total control of data, state, events,
and even the form fields FM manages.

#FM exposes only 'methods' -- there are no 'properties'.# +
All data, state and configuration caches are _private_ so they cannot
be directly mutated.
Interactions must be performed using API _getter_ and _setter_ methods.
This allows FM to keep everything perfectly synchronized.


=== Dynamic Configuration

FM followed the configuration rules it is provided,
and this can be updated _on-the-fly_ using the configuration API.
FM can seamlessly integrate with any custom logic.


=== Singular vs Plural Method-names

Many getter & setter methods have _similar_ names, except that
one is '*singular*' (eg: `getValue`) and
one is '*plural*' (eg: `getValues`).
#These are different methods with different argument signatures.#

- *Singular method-names* usually apply to _one specific field_,
  so the first argument is always a fieldname.

- *Plural method-names* usually apply to _all fields_ -or- _multiple fields_,
  so the first argument is an object, an array, or nothing!

[source]
----
// GETTERS
const username = form.getValue('username') // One value
// OR
const fieldValues = form.getValues()  // All field values
const username = fieldValues.username

// SETTERS
form.setValue('username', 'john-smith')
form.setValue('email', 'john-smith@gmail.com')
// OR
form.setValues({
    username: 'john-smith',
    email: 'john-smith@gmail.com'
})
----

Methods with names that do not have a plural form (eg: `getData`) can
apply to a specific field _or_ all fields,
depending whether a fieldname is passed.
Therefore these methods accept more than one argument signature.

[source]
----
const username = form.getData('profile.username') // One value
// OR
const formData = form.getData() // All form data
const username = formData.profile.username
----

=== Abbreviated Method-names

Some methods have alternate, shorter alias names to aid code brevity, like:

- `isFieldDisabled` -> `isDisabled`
- `getAllProps` -> `allProps`
- `getValue` -> `value`
- `getError` -> `error`

These are especially useful when used _repeatedly_ in markup, like:

[source,html]
----
<TextField label="First Name"  {...form.allProps("firstName")} />
<TextField label="Middle Name" {...form.allProps("middleName")} />
<TextField label="Last Name"   {...form.allProps("lastName")} />
----


=== Chaining Commands

All *_setter_* methods return the FormManager object so
multiple commands can be chained.
This is just a convenience -- it does _not_ change how the methods work.

[source]
----
form.setFieldRequired('phone')
form.validate('phone')

// Is the same as...
form.setFieldRequired('phone')
    .validate('phone')
----

=== Fieldname Aliases

*An alias-name can be specified for any field.*
This can be used to normalize fieldnames across different datasets,
or to simplify the concatenated names of nested fields.

An alias can be passed to _any_ FM method.
The examples below show equivalent commands, one using the alias
and the other the actual, concatenated fieldname.
Note how the alias makes the code easier to write and read.

[source]
----
// Set an aliasName for a deeply nested field
const formConfig = {
  fields: {
    'profile.contacts.primaryPhone': {
      aliasName: 'phone'
    }
  }
}

const phone = form.getValue('profile.contacts.primaryPhone')
const phone = form.getValue('phone')

form.setFieldDisabled('profile.contacts.primaryPhone')
form.setFieldDisabled('phone')

<TextField {...form.allProps('profile.contacts.primaryPhone')}
<TextField {...form.allProps('phone')}
----


== Form Rendering Methods


update / render ::
+
--
Force a re-render of the component FM is inside.

.@params (0)
++ ++

.@returns
FormManager [.small]#{object}#

.@details
[.small]#A render is _automatically_ triggered when necessary.
However, if you programmatically change form configuration,
you need to manually trigger an update for the changes to take effect.
This method provides that, and also increments the form revision value.#

.@example
[source]
----
form.update()
----
--

''''

revision / getRevision ::
+
--
Unique number for logic in `shouldComponentUpdate()`

[.small]#When using `React.PureComponent`, some props must _change_ to
trigger a component render. Since the form-manager object/prop
never changes, you need another prop to _force_ component updates.
The form revision number provides this prop.
It increments each time data in FM changes -- on every keystroke!#

.@params (0)
++ ++

.@returns
Revision Number {integer}

.@example
[source]
----
<FormFields form={this.form} rev={this.form.revision()} />
----
--

'''


== Configuration Methods

Every aspect of FM is controlled by the form-configuration.
Normally you provide a set of configuration options when you create a FM
instance for a form.
However all configuration is dynamic, and can be changed at any time.
The most common configuration changes have special methods to simplify things.
For example, changing field validation rules, disabling one or all fields,
changing the error-messages (eg: a different language), etc.


+++<details open>+++
+++<summary>+++
*setConfig | setFieldConfig*
+++</summary><div>+++
====
Foobar

[.small]#Foobar#

.@params (2)
--

. `fieldname` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `settings` {nbsp} [.small]#{object} {nbsp} [`{}`]# +
  Foobar
--

.@returns
FormManager [.small]#{object}#

.@example
[source]
----
form.setFieldConfig(
    'password',
    { disabled: true }
)
----
====
++++
</div></details>
++++

''''

setFieldDefaults ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `fieldname`* {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `settings` {nbsp} [.small]#{object} {nbsp} [`{}`]# +
  Foobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----
form.setFieldDefaults({
    validateOnChange: true,
    disabled: false
})
----
--
''''


isDisabled | isFieldDisabled ::
+
--
Foobar

[.small]#Foobar#

*@params* (1)

. `fieldname`* {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

*@returns* (true|false)

*@example*
[source]
----
if (form.isDisabled('email') {
    form.setDisabled('email', false)
}
----
--
''''


setDisabled | setFieldDisabled ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `fieldname` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `disable` {nbsp} [.small]#{boolean} `[true]`# +
  Foobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----
if (form.isDisabled('email') {
    form.setDisabled('email', false)
}
----
--
''''


setDefaultDisabled ::
+
--
Foobar

[.small]#Foobar#

*@params* (1)

. `disable` {nbsp} [.small]#{string} `[true]`# +
  Foobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----
handleSubmit() {
    const { form } = this
    // Disable all form fields, by default
    form.setDefaultDisabled(true)

    form.validateAll().then(isValid => {
        if (isValid) {
            // post the data...
        } else {
            // Re-enable all form fields, by default
            form.setDefaultDisabled(false)
        }
    }
}
----
--
''''



=== isFieldReadOnly (name)
 ::
+
--
Foobar

[.small]#Foobar#

[%autowidth, cols="<.<1m,^.<1e,<.<9"]
|===
| param | type | details

| fieldname*
| +++string+++
| +++A fieldname or alias-name+++
|===

|===
| param       | type   | details

| fieldname * | string | A fieldname or alias-name
|===

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Foobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


=== setReadOnly | setFieldReadOnly (name)
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Foobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


=== isReadOnly (name)
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Foobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


=== setDefaultReadOnly ([readOnly] = true)
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Foobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''



== Validation & Error Methods

Validation is usually handled by configuration the fields that require it,
so it is a _subset_ of configuration.
However there are cases when its useful to read, perform, or change validation
rules programatically, so there is a rich API devoted to validation rules.


=== validate (name, value, [eventName])
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Foobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


=== validateAll ()
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Foobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''



=== getFieldValidation (name)
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Foobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


=== setFieldValidation (name, settings)
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Foobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


=== getFieldConfig (name)
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Foobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


=== isRequired | isFieldRequired (name)
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Foobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


=== setRequired | setFieldRequired (name)
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Foobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


=== errors | getError | getErrors (name)
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Foobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


=== setError | setErrors (name, type, [errorMessage])
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Foobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


=== clearError | clearErrors ([name])
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Foobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


=== isClean ([name])

=== isDirty ([name])

=== reset ()


=== changes | getChanges ()

=== data | getData ([name], [options])

=== setData (nameOrData, [fieldData])



=== value | values | getValue | getValues ([name])

=== setValue | setValues (name, value)


== Form 'State' Methods


=== state | getState ([key])

=== setState (key, value)


== Form and Field Methods

ALSO SEE methods like:

 - `getValue()` in the Values section
- `getError()` in the Validation section
- `isFieldDisabled()` in the Configuration section

These methods are used to set field props,
but usually you'll use the `allProps()` or `dataProps()` helpers instead,
which _combine_ all the individual props into a single setter.


=== allProps (name)

=== dataProps (name)

=== errorProps (name)

=== cleanField | cleanFieldValue (name)

=== hasError (name)

=== hasErrors ()

=== onFieldBlur (event_or_name, [value])

=== onFieldChange (event_or_name, [value])

=== onFieldFocus (event_or_name, [value])

