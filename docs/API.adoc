= FormManager API Reference
:source-highlighter: highlightjs
:source-language: javascript
:icons: font
:toc:
:toc-placement!:

[.small]#Last update: {localdate}#

WARNING: THIS IS A JUST AN OUTLINE -- A WORK IN PROGRESS

toc::[]


== API Overview & Conventions


*FM exposes _only_ 'methods' - no 'properties'.* +
All of FM's data caches are _private_ so they cannot
be accidentally mutated.
Data interactions are performed with getter and setter methods.
Most methods also _clone_ data in both directions to maintain immutability.

*FM's' extensive API provides control of _everything_ FM handles.* +
Anything a user can do can also be done programmatically.
You have full control of the data, as well as every _field_ FM manages.


==== Singular vs Plural Method-names

Many methods have both a *singular* [`getValue()`] and
a *plural* [`getValues()`] variation. +
*These are different methods with different signatures.*

- Methods with a singular name apply to _one specific field_.
  The first argument for these methods is a fieldname.

- Methods with a plural name apply to either _all fields_ or _multiple fields_.

[source]
----
const username = form.getValue('username')  // One value
const fieldValues = form.getValues()        // All form values
----

Methods with names that do not have a simple plural form [`getData()`] can
apply to a specific field _or_ all fields,
depending whether a fieldname is passed.

[source]
----
const username = form.getData('username')  // One value
const fieldValues = form.getData()         // All form data
----

==== Alias Method-names

Some methods also have shorter alias names to aid code brevity;
particularly ones often used repeatedly in markup,
like:

- `isFieldDisabled()` -> `isDisabled()`
- `getAllProps()` -> `allProps()`
- `getValue()` -> `value()`
- `getError()` -> `error()`

[source,html]
----
<TextField label="First Name"  {...form.allProps("firstName")} />
<TextField label="Middle Name" {...form.allProps("middleName")} />
<TextField label="Last Name"   {...form.allProps("lastName")} />
----

=== Chaining Commands

All *_setter_* methods return the FormManager [.small]#{object}#,
to allow multiple commands to be chained.

[source]
----
form.setFieldRequired('phone')
form.validate('phone')

// Is the same as...
form.setFieldRequired('phone')
    .validate('phone')
----

=== Fieldname Aliases

An `aliasName` can be set for any field.
This can normalize fieldnames across different datasets,
and simplify the concatenated names of nested fields.

If an alias is set, it can be passed to _any_ FM method
instead of the actual fieldname.
In the example below, each pair of commands shown are valid and equivalent.
Note how the alias versions are much easier to write read.

[source]
----
// Set an aliasName for a deeply nested field
const formConfig = {
  fields: {
    'profile.contacts.primaryPhone': {
      aliasName: 'phone'
    }
  }
}

const phone = form.getValue('profile.contacts.primaryPhone')
const phone = form.getValue('phone')

form.setFieldDisabled('profile.contacts.primaryPhone')
form.setFieldDisabled('phone')

<TextField {...form.allProps('profile.contacts.primaryPhone')}
<TextField {...form.allProps('phone')}
----

''''

== Form Rendering Methods


update / render ::
+
--
Force a re-render of the component FM is inside.

[.small]#FM _automatically_ triggers renders when necessary.
However if you programically change form configuration,
you need to trigger a re-render for the changes to take effect.
This method provides that, and also increments the form revision value.#

*@params* (0) +
*@returns* FormManager [.small]#{object}#
--

''''

revision / getRevision ::
+
--
Unique number for logic in `shouldComponentUpdate()`

[.small]#When using `React.PureComponent`, some props must _change_ to
trigger a component render. Since the form-manager object/prop
never changes, you need another prop to _force_ component updates.
The form revision number provides this prop.
It increments each time data in FM changes -- on every keystroke!#

*@params* (0) +
*@returns* Revision Number {integer}

*@example*
[source]
----
<FormFields form={this.form} rev={this.form.revision()} />
----
--

'''


== Configuration Methods

Every aspect of FM is controlled by the form-configuration.
Normally you provide a set of confuration options when you create a FM
instance for a form.
However all configuration is dynamic, and can be changed at any time.
The most common configuration changes have special methods to simplify things.
For example, changing field validation rules, disabling one or all fields,
changing the error-messages (eg: a different languange), etc.


setConfig | setFieldConfig ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `fieldname` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `settings` {nbsp} [.small]#{object} {nbsp} [`{}`]# +
  Fobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----
form.setFieldConfig(
    'password',
    { disabled: true }
)
----
--
''''


setFieldDefaults ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `fieldname`* {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `settings` {nbsp} [.small]#{object} {nbsp} [`{}`]# +
  Fobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----
form.setFieldDefaults({
    validateOnChange: true,
    disabled: false
})
----
--
''''


isDisabled | isFieldDisabled ::
+
--
Foobar

[.small]#Foobar#

*@params* (1)

. `fieldname`* {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

*@returns* (true|false)

*@example*
[source]
----
if (form.isDisabled('email') {
    form.setDisabled('email', false)
}
----
--
''''


setDisabled | setFieldDisabled ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `fieldname` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `disable` {nbsp} [.small]#{boolean} `[true]`# +
  Fobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----
if (form.isDisabled('email') {
    form.setDisabled('email', false)
}
----
--
''''


setDefaultDisabled ::
+
--
Foobar

[.small]#Foobar#

*@params* (1)

. `disable` {nbsp} [.small]#{string} `[true]`# +
  Foobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----
handleSubmit() {
    const { form } = this
    // Disable all form fields, by default
    form.setDefaultDisabled(true)

    form.validateAll().then(isValid => {
        if (isValid) {
            // post the data...
        } else {
            // Re-enable all form fields, by default
            form.setDefaultDisabled(false)
        }
    }
}
----
--
''''



==== isFieldReadOnly (name)
 ::
+
--
Foobar

[.small]#Foobar#

.@params
[%autowidth, cols="1m,^1e,9"]
|===
| param | type | details

| fieldname *
| string
| A fieldname or alias-name
|===

|===
| param       | type   | details

| fieldname * | string | A fieldname or alias-name
|===

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Fobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


==== setReadOnly | setFieldReadOnly (name)
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Fobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


==== isReadOnly (name)
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Fobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


==== setDefaultReadOnly ([readOnly] = true)
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Fobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''



== Validation & Error Methods

Validation is usually handled by configuration the fields that require it,
so it is a _subset_ of configuration.
However there are cases when its useful to read, perform, or change validation
rules programatically, so there is a rich API devoted to validation rules.


==== validate (name, value, [eventName])
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Fobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


==== validateAll ()
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Fobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''



==== getFieldValidation (name)
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Fobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


==== setFieldValidation (name, settings)
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Fobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


==== getFieldConfig (name)
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Fobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


==== isRequired | isFieldRequired (name)
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Fobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


==== setRequired | setFieldRequired (name)
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Fobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


==== errors | getError | getErrors (name)
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Fobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


==== setError | setErrors (name, type, [errorMessage])
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Fobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''


==== clearError | clearErrors ([name])
 ::
+
--
Foobar

[.small]#Foobar#

*@params* (2)

. `param` {nbsp} [.small]#{string} {nbsp} [`""`]# +
  Foobar

. `param` {nbsp} [.small]#{integer} {nbsp} [`0`]# +
  Fobar

*@returns* FormManager [.small]#{object}#

*@example*
[source]
----

----
--
''''



== Data & Value Methods

FM _caches_ and _synchronizes_ two separate sets of data.
It is important to understand the difference when deciding which
API methods to use.

Methods containing the word "data" target the Data cache,
while those containing "value" target the Values cache.
However changes to either cache are immediately _synced_ to the other.
When you want to programically set data in a form-field,
a Value method should be used.
If you need to update the _source_ data, use a Data method.

Any change to _either_ cache will immediately update the Data cache.
If a data transformation is required, it is done on the fly.

=== 'Data' Cache

The 'Data' cache starts as a _copy_ of the data originally supplied to FM,
if any was. This cache has the same structure and fieldnames as the source.
When any 'data getter' (eg: `getData()`) is called,
the data will be returned in the source structure, ready to be posted.

FM tracks the _original_ data, so knows precisely which data has
changed since the form was initialized.
This is useful if you want to do a PATCH update.

Data tracking also allows FM to know whether the form is 'clean' or 'dirty'.
If a user changes a value, then later changes it _back_ to the original value,
FM knows that this data value is _no longer_ 'changed'.


=== 'Values' Cache

The 'Values' cache contains the values supplied to the form fields via props.
These values may be a different data-type of format than the source data,
to suit the requirements of each field-type.

*The Values cache is a single level deep.* There has no _nested keys_.
Nested structures from the 'Data' cache are flattened to become 'paths',
like `"user.profile.address.street"`.
These paths are the keys used in the Values object,
and are used as the *fieldnames* in the form...

=== Field aliasName

Instead of using long 'path-names' (eg: "user.profile.address.street"),
an '*aliasName*' can is set in a field's configuration,
like `"addressStreet"`.
All code can then _optionally_ use this alias instead of the path-name.
Using aliases is recommended to make form markup simpler.

Aliases can also be used to _normalize_ fieldnames from different datasets.
For example, if you have multiple sets of data than contain an address,
and these don't all have identical fieldnames,
then aliases can normalize them so they can use the same `<AddressForm>`
component, without needing any extra logic.


==== isClean ([name])

==== isDirty ([name])

==== reset ()


==== changes | getChanges ()

==== data | getData ([name], [options])

==== setData (nameOrData, [fieldData])



==== value | values | getValue | getValues ([name])

==== setValue | setValues (name, value)


== Form 'State' Methods


==== state | getState ([key])

==== setState (key, value)


== Form and Field Methods

ALSO SEE methods like:

 - `getValue()` in the Values section
- `getError()` in the Validation section
- `isFieldDisabled()` in the Configuration section

These methods are used to set field props,
but usually you'll use the `allProps()` or `dataProps()` helpers instead,
which _combine_ all the individual props into a single setter.


==== allProps (name)

==== dataProps (name)

==== errorProps (name)

==== cleanField | cleanFieldValue (name)

==== hasError (name)

==== hasErrors ()

==== onFieldBlur (event_or_name, [value])

==== onFieldChange (event_or_name, [value])

==== onFieldFocus (event_or_name, [value])

