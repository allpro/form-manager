import cloneDeep from 'lodash/cloneDeep'
import defaults from 'lodash/defaults'
import defaultsDeep from 'lodash/defaultsDeep'
import forOwn from 'lodash/forEach'
import isArray from 'lodash/isArray'
import isNil from 'lodash/isNil'
import isPlainObject from 'lodash/isPlainObject'
import isString from 'lodash/isString'
import merge from 'lodash/merge'
import omit from 'lodash/omit'
import reduce from 'lodash/reduce'
// Alias validateField because we use an intermediate method with same name
import defaultValidators from './validators'
import defaultFormatters from './formatters'
import defaultConverters from './converters'
import defaultFormConfig from './defaultFormConfig'
import defaultFieldConfig from './defaultFieldConfig'
import defaultErrorMessages from './defaultErrorMessages'
import utils from './utils'

// Extract utils for code brevity
const { getObjectValue, setObjectValue } = utils


/**
 * FormManager sub-component to handle form and field configuration
 *
 * @param {Object} formManager    FormManager instance object
 * @param {Object} [components]        Hash of FormManager sub-components
 * @returns {Object}                Config API for this instance
 * @constructor
 */
function Config( formManager, components ) {
	// Auto-instantiate so 'new' keyword is NOT required
	// (It's best practice to not require 'new' as it's an internal design)
	if (!(this instanceof Config)) {
		return new Config(formManager, components)
	}

	const { internal } = components

	// Form-Configuration cache - data accessible only via config methods
	const config = {}

	/**
	 * CONFIG API - provides simplified method names for internal functions
	 */
	return {
		// Methods used internally by FormManager components
		init,
		get: getAtPath,
		getField: getFieldConfig,	// GETTER for field configuration
		setField: setFieldConfig, 	// SETTER for field configuration
		getValidation: getFieldValidation,	// GETTER for field configuration
		setValidation: setFieldValidation, 	// SETTER for field configuration
		aliasToRealName,
		withFieldDefaults,

		// Methods exposed in FormManager API
		publicAPI: {
			getFieldConfig, 		// GETTER for field configuration
			setFieldConfig, 		// SETTER for field configuration
			getFieldValidation,		// GETTER for validation config
			setFieldValidation,		// SETTER for validation config
			isRequired,				// GETTER for validation.required
			setRequired,			// SETTER for validation.required
			isDisabled,				// GETTER for field.disabled
			setDisabled,			// SETTER for field.disabled
			isReadOnly,				// GETTER for field.readOnly
			setReadOnly				// SETTER for field.readOnly
		}
	}


	/**
	 * Initialization method to set internal configuration.
	 * NOTE that config.fields can be an array OR a hash keyed by fieldname.
	 */
	function init( options ) {
		// IGNORE option keys auto-generated by setFieldConfig()
		merge(config, omit(options, ['fields', 'fieldAliasMap']))

		// Add all default form values
		defaultsDeep(config, defaultFormConfig)
		defaults(config.formatters, defaultFormatters)
		defaults(config.validators, defaultValidators)
		defaults(config.converters, defaultConverters)
		defaults(config.errorMessages, defaultErrorMessages)

		// Now configure each form-field
		setFieldConfig(options.fields)
	}


	function getAtPath( path ) {
		return getObjectValue(config, path)
	}


	/**
	 * Get field-config for ONE-OR-ALL FIELDS
	 *
	 * @param {string} [name]
	 * @returns {Object}    Returns fieldConfig for one or all fields
	 */
	function getFieldConfig( name ) {
		const fieldName = aliasToRealName(name)
		const fields = config.fields
		return cloneDeep(name ? fields[fieldName] : fields)
	}

	/**
	 * Set field-config for one or more fields
	 * Accepts an array -or- hash keyed by fieldname to set multiple fields.
	 *
	 * @param {(string|Array|Object)} [name]
	 * @param {(Object|Array|string)} [data]
	 * @param {Object} [opts]       Option for merging with existing config
	 * @returns {Object}            All SETTERS return instance for chaining
	 */
	function setFieldConfig( name, data, opts = {} ) {
		const isNamePassed = isString(name)

		// 2nd & 3rd arguments SHIFT if 'name' (string) is not passed
		const configData = isNamePassed ? data : name
		const configOpts = merge(
			{ replace: false, fieldName: '' },
			isNamePassed ? opts : data
		)
		const fields = config.fields

		const set = ( n, newConfigData, replace ) => {
			// A field-name is required
			if (!n) return

			const fieldName = aliasToRealName(n)
			let fieldConfig = fields[fieldName]

			// INIT fieldConfig if not exists, OR if opts.replace specified
			if (!fieldConfig || replace) {
				fieldConfig = fields[fieldName] = cloneDeep(defaultFieldConfig)
			}

			merge(fieldConfig, newConfigData)

			// ensure field.name is set - may have been passed as opts.fieldName
			fieldConfig.name = fieldName

			if (fieldConfig.aliasName) {
				config.fieldAliasMap[fieldConfig.aliasName] = fieldName
			}
		}

		// SINGLE FIELD UPDATE
		if (isNamePassed) {
			set(name, configData, configOpts.replace)
		}
		// SINGLE -OR- MULTIPLE FIELDS, AS A HASH...
		else if (isPlainObject(configData)) {
			const singleFieldName = configData.name || configOpts.fieldName

			// SINGLE FIELD UPDATE
			if (singleFieldName && isString(singleFieldName)) {
				set(singleFieldName, configData, configOpts.replace)
			}
			// MULTIPLE FIELD UPDATE (keyed by fieldname)
			else {
				forOwn(configData, ( cfg, n ) => {
					set(n, cfg, true)
				})
			}
		}
		// MULTIPLE FIELD UPDATE - CONFIGS AS ARRAY
		// (requires a 'name' key inside each config hash)
		else if (isArray(configData)) {
			for (const cfg of configData) {
				if (isPlainObject(cfg)) {
					set(cfg.name, cfg, true)
				}
			}
		}

		internal.triggerComponentUpdate()

		return formManager
	}


	/**
	 * PUBLIC GETTER for field validation options
	 *
	 * @public
	 * @param {string} name     Fieldname to get
	 * @returns {Object}        Validation-config in getter mode
	 */
	function getFieldValidation( name ) {
		return cloneDeep(getField(name, '.validation'))
	}

	/**
	 * PUBLIC SETTER for field validation options
	 *
	 * @public
	 * @param {string} name             Fieldname to get/set
	 * @param {Object} [settings]       New Validation setting(s)
	 * @param {Object} [opts]            Option for merging with existing config
	 * @returns {Object}                All SETTERS return instance for chaining
	 */
	function setFieldValidation( name, settings, opts = { merge: false } ) {
		const newSettings = cloneDeep(settings)
		setField(name, '.validation', newSettings, opts)
		return formManager
	}


	/**
	 * PUBLIC GETTER for 'validation.required' flag.
	 *
	 * @public
	 * @param {(string|Array)} name    Fieldname (or array of), for mass update
	 * @returns {(boolean|Object)}     Returns true/false OR a hash of values
	 */
	function isRequired( name ) {
		return getField(name, '.validation.required') || false
	}

	/**
	 * PUBLIC SETTER for validation 'required' flag.
	 *
	 * @public
	 * @param {(Array|string)} name     Fieldname (or array of), for mass update
	 * @param {boolean} required        Set this field(s) required?
	 * @returns {Object}                All SETTERS return instance for chaining
	 */
	function setRequired( name, required ) {
		setField(name, '.validation.required', !!required)
		return formManager
	}


	/**
	 * PUBLIC GETTER for field.disabled flag.
	 *
	 * @public
	 * @param {(string|Array)} name    Fieldname (or array of), for mass update
	 * @returns {(boolean|Object)}     Returns true/false OR a hash of values
	 */
	function isDisabled( name ) {
		return getField(name, '.disabled') || false
	}

	/**
	 * PUBLIC SETTER for field.disabled flag.
	 *
	 * @public
	 * @param {(Array|string)} name    Fieldname (or array of), for mass update
	 * @param {boolean} disabled       Set this field(s) disabled?
	 * @returns {Object}                All SETTERS return instance for chaining
	 */
	function setDisabled( name, disabled ) {
		setField(config, name, '.disabled', !!disabled)
		return formManager
	}


	/**
	 * PUBLIC GETTER for field.readOnly flag.
	 *
	 * @public
	 * @param {(Array|string)} name    Fieldname (or array of), for mass update
	 * @returns {(boolean|Object)}     Returns true/false OR a hash of values
	 */
	function isReadOnly( name ) {
		return getField(name, '.readOnly') || false
	}

	/**
	 * PUBLIC SETTER for field.readOnly flag.
	 *
	 * @public
	 * @param {(Array|string)} name    Fieldname (or array of), for mass update
	 * @param {boolean} readOnly    Is this field(s) disabled?
	 * @returns {Object}            All SETTERS return instance for chaining
	 */
	function setReadOnly( name, readOnly ) {
		setField(config, name, '.readOnly', !!readOnly)
		return formManager
	}


	/**
	 * Helper for getting field config values
	 *
	 * @param {string} name        Fieldname - may be an alias
	 * @param {string} branch    Path inside field-config to return
	 * @returns {string}        Complete
	 */
	function getField( name, branch ) {
		const get = n => {
			const fieldName = aliasToRealName(n)
			const path = `fields.${fieldName}.${branch}`
			return getObjectValue(config, path)
		}

		return isArray(name)
			? reduce(name, ( obj, n ) => { obj[n] = get(n) })
			: get(name)
	}

	/**
	 * Helper for setting field config values
	 *
	 * @param {string} name         Fieldname - may be an alias
	 * @param {string} branch       Path inside field-config to return
	 * @param {*} value            Value to be set
	 * @param {Object} [opts]       Options to pass to setObjectValue()
	 */
	function setField( name, branch, value, opts = {} ) {
		let somethingChanged = false

		const set = n => {
			const fieldName = aliasToRealName(n)
			const path = `fields.${fieldName}.${branch}`
			const oldValue = getObjectValue(config, path)

			if (value !== oldValue) {
				setObjectValue(config, path, value, opts)
				somethingChanged = true
			}
		}

		if (isArray(name)) {
			for (const n of name) set(n)
		}
		else {
			set(name)
		}

		if (somethingChanged) {
			internal.triggerComponentUpdate()
		}
	}


	/**
	 * Helper to convert aliasName to fieldName
	 * @param name            The name OR aliasName of a field
	 * @returns {string}    If alias found then mapped fieldName, else name
	 */
	function aliasToRealName( name ) {
		if (!name) return name
		if (isArray(name)) return name.map(aliasToRealName)

		if (config.fields[name]) return name

		const realName = config.fieldAliasMap[name]
		if (config.fields[realName]) return realName

		// field nay not have a field-configuration, so can't find the name
		return name
	}


	/**
	 * Helper that looks for EITHER A field-specific OR default config option
	 * @param {Object} fieldConfig
	 * @param {string} path
	 * @returns {undefined|*}
	 */
	function withFieldDefaults( fieldConfig, path ) {
		// If field specifies a value, use it!
		const fieldConfigValue = getObjectValue(fieldConfig, path)
		if (!isNil(fieldConfigValue)) return fieldConfigValue

		const defaultValue = getObjectValue(config.fieldDefaults, path)
		if (!isNil(defaultValue)) return defaultValue

		return undefined
	}
}

// noinspection JSUnusedGlobalSymbols
export default Config
