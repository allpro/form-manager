import {
	cloneDeep,
	forOwn,
	isArray,
	isNil,
	isPlainObject,
	merge,
	omit,
	defaults,
	defaultsDeep,
	getObjectValue,
	setObjectValue
} from './utils'

// Alias validateField because we use an intermediate method with same name
import defaultValidators from './validators'
import defaultFormatters from './formatters'
import defaultConverters from './converters'
import defaultFormConfig from './defaultFormConfig'
import defaultFieldConfig from './defaultFieldConfig'
import defaultErrorMessages from './defaultErrorMessages'


/**
 * FormManager sub-component to handle form and field configuration
 *
 * @param {Object} formManager    FormManager instance object
 * @param {Object} [components]        Hash of FormManager sub-components
 * @returns {Object}                Config API for this instance
 * @constructor
 */
function Config( formManager, components ) {
	// Auto-instantiate so 'new' keyword is NOT required
	// (It's best practice to not require 'new' as it's an internal design)
	if (!(this instanceof Config)) {
		return new Config(formManager, components)
	}

	const { internal } = components

	// Extract helper methods for brevity
	const { triggerComponentUpdate } = internal

	// Form-Configuration cache - data accessible only via config methods
	const formConfig = {}

	/**
	 * CONFIG API - provides simplified method names for internal functions
	 */
	return {
		// Methods used internally by FormManager components
		init,
		get: getAtPath,
		getField: getFieldConfig,			// GETTER for field config
		getFields: getFieldsConfig,			// GETTER for field config
		getValidation: getFieldValidation,	// GETTER for field config
		aliasToRealName,
		withFieldDefaults,

		// Methods exposed in FormManager API
		publicAPI: {
			setConfig,						// SETTER for ANY config keys
			setErrorMessages,				// SETTER for config.errorMessages
			getFieldDefaults,				// GETTER for fieldDefaults config
			setFieldDefaults,				// SETTER for fieldDefaults config
			getFieldConfig, 				// GETTER for one field config
			getFieldsConfig, 				// GETTER for all field configs
			setFieldConfig, 				// SETTER for field config
			setFieldsConfig, 				// SETTER for field config
			getFieldValidation,				// GETTER for validation config
			setFieldValidation,				// SETTER for validation config
			isFieldRequired,				// GETTER for validation.required
			setFieldRequired,				// SETTER for validation.required
			isFieldDisabled,				// GETTER for field.disabled
			setFieldDisabled,				// SETTER for field.disabled
			isFieldReadOnly,				// GETTER for field.readOnly
			setFieldReadOnly,				// SETTER for field.readOnly
			setDefaultDisabled,				// SETTER for fieldDefaults.disabled
			setDefaultReadOnly,				// SETTER for fieldDefaults.readOnly
			// Aliases
			isRequired: isFieldRequired,	// GETTER for validation.required
			setRequired: setFieldRequired,	// SETTER for validation.required
			isDisabled: isFieldDisabled,	// GETTER for field.disabled
			setDisabled: setFieldDisabled,	// SETTER for field.disabled
			isReadOnly: isFieldReadOnly,	// GETTER for field.readOnly
			setReadOnly: setFieldReadOnly,	// SETTER for field.readOnly
		}
	}


	/**
	 * Initialization method to set internal configuration.
	 * NOTE that config.fields can be an array OR a hash keyed by fieldname.
	 */
	function init( config ) {
		// IGNORE option keys auto-generated by setFieldConfig()
		merge(formConfig, omit(config, ['fields', 'fieldAliasMap']))

		// Add all default config data
		defaultsDeep(formConfig, defaultFormConfig)
		defaults(formConfig.formatters, defaultFormatters)
		defaults(formConfig.validators, defaultValidators)
		defaults(formConfig.converters, defaultConverters)
		defaults(formConfig.errorMessages, defaultErrorMessages)

		// Now configure each form-field
		if (config.fields) {
			setFieldsConfig(config.fields)
		}
	}


	/**
	 * Set config for ANYTHING!
	 * Accepts an array -or- hash keyed by fieldname to set multiple fields.
	 *
	 * @param {Object} config		Hash of configuration changes
	 * @returns {Object}            All SETTERS return instance for chaining
	 */
	function setConfig( config ) {
		// IGNORE option keys auto-generated by setFieldConfig()
		merge(formConfig, omit(config, ['fields', 'fieldAliasMap']))

		// Now configure each form-field
		if (config.fields) {
			setFieldsConfig(config.fields)
		}

		return triggerComponentUpdate()
	}

	/**
	 * PUBLIC METHOD for changing the entire ErrorMessages object
	 * @param {Object} errorMessages
	 * @returns {*}
	 */
	function setErrorMessages( errorMessages ) {
		merge( formConfig.errorMessages, errorMessages )
		return triggerComponentUpdate()
	}


	function getAtPath( path ) {
		return getObjectValue(formConfig, path)
	}


	/**
	 * Get field-config for ALL FIELDS
	 *
	 * @returns {Object}
	 */
	function getFieldsConfig() {
		return cloneDeep(formConfig.fields)
	}

	/**
	 * Get field-config for ONE FIELD
	 *
	 * @param {string} [name]
	 * @returns {Object}
	 */
	function getFieldConfig( name ) {
		const fieldName = aliasToRealName(name)
		return cloneDeep(formConfig.fields[fieldName]) // may be undefined
	}

	/**
	 * Set field-config for one field
	 * Accepts a hash of field configuration.
	 *
	 * @param {string} name
	 * @param {Object} config
	 * @param {Object} [opts]       Option for merging with existing config
	 * @returns {Object}            All SETTERS return instance for chaining
	 */
	function setFieldConfig( name, config, opts = {} ) {
		const fieldName = aliasToRealName(name)
		const fields = formConfig.fields
		let fieldConfig = fields[fieldName]

		// INIT fieldConfig if not exists, OR if opts.replace specified
		if (!fieldConfig || opts.replace) {
			fieldConfig = fields[fieldName] = cloneDeep(defaultFieldConfig)
		}

		merge(fieldConfig, config)

		// ensure field.name is set - may have been passed as opts.fieldName
		fieldConfig.name = fieldName

		const { aliasName } = fieldConfig
		if (aliasName) {
			formConfig.fieldAliasMap[aliasName] = fieldName
		}

		if (opts.update !== false) {
			triggerComponentUpdate()
		}

		return formManager
	}

	/**
	 * Set field-config for multiple fields
	 * Accepts an array -or- hash keyed by fieldname to set multiple fields.
	 *
	 * @param {(Object|Array)} config
	 * @param {Object} [opts]       Option for merging with existing config
	 * @returns {Object}            All SETTERS return instance for chaining
	 */
	function setFieldsConfig( config, opts = {} ) {
		// Avoid multiple re-renders - will do once after all config updates
		const passOpts = merge({}, opts, { update: false })

		// MULTIPLE FIELDS AS HASH
		if (isPlainObject(config)) {
			forOwn(config, ( cfg, name ) => {
				setFieldConfig(name, cfg, passOpts)
			})
		}
		// MULTIPLE FIELDS AS ARRAY
		// (requires a 'name' key inside each config hash)
		else if (isArray(config)) {
			for (const cfg of config) {
				if (isPlainObject(cfg)) {
					setFieldConfig(cfg.name, cfg, passOpts)
				}
			}
		}

		return triggerComponentUpdate()
	}


	/**
	 * PUBLIC GETTER for fieldDefaults config
	 * Accepts hash keyed by fieldname to set multiple fields.
	 *
	 * @param {string} key
	 * @returns {*}
	 */
	function getFieldDefaults( key ) {
		return getObjectValue(formConfig, `fieldDefaults.${key}`)
	}

	/**
	 * PUBLIC SETTER for fieldDefaults config
	 *
	 * @param {Object} config
	 * @returns {Object}            All SETTERS return instance for chaining
	 */
	function setFieldDefaults( config ) {
		merge(formConfig.fieldDefaults, config)
		return triggerComponentUpdate()
	}


	/**
	 * PUBLIC GETTER for field validation options
	 *
	 * @public
	 * @param {string} name     Fieldname to get
	 * @returns {Object}        Validation-config in getter mode
	 */
	function getFieldValidation( name ) {
		return cloneDeep(getField(name, 'validation'))
	}

	/**
	 * PUBLIC SETTER for field validation options
	 *
	 * @public
	 * @param {string} name             Fieldname to get/set
	 * @param {Object} [config]       New Validation setting(s)
	 * @param {Object} [opts]            Option for merging with existing config
	 * @returns {Object}                All SETTERS return instance for chaining
	 */
	function setFieldValidation( name, config, opts = { merge: false } ) {
		const newSettings = cloneDeep(config)
		return setFieldConfigValue(name, 'validation', newSettings, opts)
	}


	/**
	 * PUBLIC GETTER for 'validation.required' flag.
	 *
	 * @public
	 * @param {string} name
	 * @returns {boolean}
	 */
	function isFieldRequired( name ) {
		return getField(name, 'validation.required') || false
	}

	/**
	 * PUBLIC SETTER for validation.required flag.
	 *
	 * @public
	 * @param {string} name
	 * @param {boolean} enable
	 * @returns {Object}      	All SETTERS return instance for chaining
	 */
	function setFieldRequired( name, enable = true ) {
		return setFieldConfigValue(name, 'validation.required', !!enable)
	}


	/**
	 * PUBLIC GETTER for field.disabled flag.
	 *
	 * @public
	 * @param {string} name
	 * @returns {boolean}
	 */
	function isFieldDisabled( name ) {
		const disabled = getField(name, 'disabled')
		return disabled || formConfig.fieldDefaults.disabled || false
	}

	/**
	 * PUBLIC SETTER for field.disabled flag.
	 * Setting 'false' means REMOVE the disabled flag so will use fieldDefaults
	 *
	 * @public
	 * @param {string} name
	 * @param {boolean} enable
	 * @returns {Object}      	All SETTERS return instance for chaining
	 */
	function setFieldDisabled( name, enable = true ) {
		return setFieldConfigValue(name, 'disabled', !!enable || undefined)
	}

	/**
	 * PUBLIC SETTER for fieldDefaults.disabled flag.
	 *
	 * @public
	 * @param {boolean} enable
	 * @returns {Object}      	All SETTERS return instance for chaining
	 */
	function setDefaultDisabled( enable = true ) {
		return setFieldDefaults({ disabled: !!enable })
	}


	/**
	 * PUBLIC GETTER for field.readOnly flag.
	 *
	 * @public
	 * @param {string} name
	 * @returns {boolean}
	 */
	function isFieldReadOnly( name ) {
		const readOnly = getField(name, 'readOnly')
		return readOnly || formConfig.fieldDefaults.readOnly || false
	}

	/**
	 * PUBLIC SETTER for field.readOnly flag.
	 * Setting 'false' means REMOVE the readOnly flag so will use fieldDefaults
	 *
	 * @public
	 * @param {string} name
	 * @param {boolean} enable
	 * @returns {Object}      	All SETTERS return instance for chaining
	 */
	function setFieldReadOnly( name, enable = true ) {
		return setFieldConfigValue(name, 'readOnly', !!enable || undefined)
	}

	/**
	 * PUBLIC SETTER for fieldDefaults.readOnly flag.
	 *
	 * @public
	 * @param {boolean} enable
	 * @returns {Object}      	All SETTERS return instance for chaining
	 */
	function setDefaultReadOnly( enable = true ) {
		return setFieldDefaults({ readOnly: !!enable })
	}


	/**
	 * Helper for getting field config values
	 *
	 * @param {string} name        	Fieldname - may be an alias
	 * @param {string} branch    	Path inside field-config to return
	 * @returns {(Object|*)} 		ONE Field-config-value for a field(s)
	 */
	function getField( name, branch ) {
		const get = n => {
			const fieldName = aliasToRealName(n)
			const path = `fields.${fieldName}.${branch}`
			return getObjectValue(formConfig, path)
		}

		// noinspection JSUnresolvedFunction
		return isArray(name)
			// Return an object with passed names as the keys
			? name.reduce(( obj, n ) => { obj[n] = get(n); return obj }, {})
			: get(name)
	}

	/**
	 * INTERNAL HELPER for setting field config values
	 *
	 * @param {string} name         Fieldname - may be an alias
	 * @param {string} branch       Path inside field-config to return
	 * @param {*} value            	Value to be set
	 * @param {Object} [opts]       Options to pass to setObjectValue()
	 * @returns {Object}       		All SETTERS return instance for chaining
	 */
	function setFieldConfigValue( name, branch, value, opts = {} ) {
		let somethingChanged = false

		const set = n => {
			const fieldName = aliasToRealName(n)
			// Must use array because fieldName may contain dots (nested field)
			const path = ['fields', fieldName, branch]
			const oldValue = getObjectValue(formConfig, path)

			if (value !== oldValue) {
				setObjectValue(formConfig, path, value, opts)
				somethingChanged = true
			}
		}

		if (isArray(name)) {
			for (const n of name) set(n)
		}
		else {
			set(name)
		}

		if (somethingChanged) {
			triggerComponentUpdate()
		}

		return formManager
	}


	/**
	 * Helper to convert aliasName to fieldName
	 * @param name            The name OR aliasName of a field
	 * @returns {string}    If alias found then mapped fieldName, else name
	 */
	function aliasToRealName( name ) {
		if (!name) return name
		if (isArray(name)) return name.map(aliasToRealName)

		if (formConfig.fields[name]) return name

		const realName = formConfig.fieldAliasMap[name]
		if (formConfig.fields[realName]) return realName

		// field nay not have a field-configuration, so can't find the name
		return name
	}


	/**
	 * Helper that looks for EITHER A field-specific OR default config option
	 * @param {Object} config
	 * @param {string} path
	 * @returns {undefined|*}
	 */
	function withFieldDefaults( config, path ) {
		// If field specifies a value, use it!
		const fieldValue = getObjectValue(config || {}, path)
		if (!isNil(fieldValue)) return fieldValue

		// Otherwise check the fieldDefaults for a value
		const defaultValue = getObjectValue(formConfig.fieldDefaults, path)
		if (!isNil(defaultValue)) return defaultValue

		return undefined
	}
}

// noinspection JSUnusedGlobalSymbols
export default Config
