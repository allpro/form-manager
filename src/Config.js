import {
	cloneDeep,
	forOwn,
	isArray,
	isNil,
	isPlainObject,
	isString,
	merge,
	omit,
	defaults,
	defaultsDeep,
	getObjectValue,
	setObjectValue
} from './utils'

// Alias validateField because we use an intermediate method with same name
import defaultValidators from './validators'
import defaultFormatters from './formatters'
import defaultConverters from './converters'
import defaultFormConfig from './defaultFormConfig'
import defaultFieldConfig from './defaultFieldConfig'
import defaultErrorMessages from './defaultErrorMessages'


/**
 * FormManager sub-component to handle form and field configuration
 *
 * @param {Object} formManager    FormManager instance object
 * @param {Object} [components]        Hash of FormManager sub-components
 * @returns {Object}                Config API for this instance
 * @constructor
 */
function Config( formManager, components ) {
	// Auto-instantiate so 'new' keyword is NOT required
	// (It's best practice to not require 'new' as it's an internal design)
	if (!(this instanceof Config)) {
		return new Config(formManager, components)
	}

	const { internal } = components

	// Form-Configuration cache - data accessible only via config methods
	const config = {}

	/**
	 * CONFIG API - provides simplified method names for internal functions
	 */
	return {
		// Methods used internally by FormManager components
		init,
		get: getAtPath,
		getField: getFieldConfig,			// GETTER for field configuration
		setField: setFieldConfig, 			// SETTER for field configuration
		getValidation: getFieldValidation,	// GETTER for field configuration
		setValidation: setFieldValidation, 	// SETTER for field configuration
		aliasToRealName,
		withFieldDefaults,

		// Methods exposed in FormManager API
		publicAPI: {
			setConfig,						// SETTER for ANY configuration keys
			setFieldDefaults,				// SETTER for fieldDefaults config
			getFieldConfig, 				// GETTER for field configuration
			setFieldConfig, 				// SETTER for field configuration
			getFieldValidation,				// GETTER for validation config
			setFieldValidation,				// SETTER for validation config
			isFieldRequired,				// GETTER for validation.required
			setFieldRequired,				// SETTER for validation.required
			isFieldDisabled,				// GETTER for field.disabled
			setFieldDisabled,				// SETTER for field.disabled
			isFieldReadOnly,				// GETTER for field.readOnly
			setFieldReadOnly,				// SETTER for field.readOnly
			setDefaultDisabled,				// SETTER for fieldDefaults.disabled
			setDefaultReadOnly,				// SETTER for fieldDefaults.readOnly
			// Aliases
			isRequired: isFieldRequired,	// GETTER for validation.required
			setRequired: setFieldRequired,	// SETTER for validation.required
			isDisabled: isFieldDisabled,	// GETTER for field.disabled
			setDisabled: setFieldDisabled,	// SETTER for field.disabled
			isReadOnly: isFieldReadOnly,	// GETTER for field.readOnly
			setReadOnly: setFieldReadOnly,	// SETTER for field.readOnly
		}
	}


	/**
	 * Initialization method to set internal configuration.
	 * NOTE that config.fields can be an array OR a hash keyed by fieldname.
	 */
	function init( options ) {
		// IGNORE option keys auto-generated by setFieldConfig()
		merge(config, omit(options, ['fields', 'fieldAliasMap']))

		// Add all default form values
		defaultsDeep(config, defaultFormConfig)
		defaults(config.formatters, defaultFormatters)
		defaults(config.validators, defaultValidators)
		defaults(config.converters, defaultConverters)
		defaults(config.errorMessages, defaultErrorMessages)

		// Now configure each form-field
		if (options.fields) {
			setFieldConfig(options.fields)
		}
	}


	/**
	 * Set field-config for one or more fields
	 * Accepts an array -or- hash keyed by fieldname to set multiple fields.
	 *
	 * @param {Object} options		Hash of configuration changes
	 * @returns {Object}            All SETTERS return instance for chaining
	 */
	function setConfig( options ) {
		// IGNORE option keys auto-generated by setFieldConfig()
		merge(config, omit(options, ['fields', 'fieldAliasMap']))

		// Now configure each form-field
		if (options.fields) {
			setFieldConfig(options.fields)
		}

		internal.triggerComponentUpdate()

		return formManager
	}


	function getAtPath( path ) {
		return getObjectValue(config, path)
	}


	/**
	 * Get field-config for ONE-OR-ALL FIELDS
	 *
	 * @param {string} [name]
	 * @returns {Object}    Returns fieldConfig for one or all fields
	 */
	function getFieldConfig( name ) {
		const fieldName = aliasToRealName(name)
		const fields = config.fields
		return cloneDeep(name ? fields[fieldName] : fields)
	}

	/**
	 * Set field-config for one or more fields
	 * Accepts an array -or- hash keyed by fieldname to set multiple fields.
	 *
	 * @param {(string|Array|Object)} [name]
	 * @param {(Object|Array|string)} [data]
	 * @param {Object} [opts]       Option for merging with existing config
	 * @returns {Object}            All SETTERS return instance for chaining
	 */
	function setFieldConfig( name, data, opts = {} ) {
		const isNamePassed = isString(name)

		// 2nd & 3rd arguments SHIFT if 'name' (string) is not passed
		const configData = isNamePassed ? data : name
		const configOpts = merge(
			{ replace: false, fieldName: '' },
			isNamePassed ? opts : data
		)
		const fields = config.fields

		const set = ( n, newConfigData, replace ) => {
			// A field-name is required
			if (!n) return

			const fieldName = aliasToRealName(n)
			let fieldConfig = fields[fieldName]

			// INIT fieldConfig if not exists, OR if opts.replace specified
			if (!fieldConfig || replace) {
				fieldConfig = fields[fieldName] = cloneDeep(defaultFieldConfig)
			}

			merge(fieldConfig, newConfigData)

			// ensure field.name is set - may have been passed as opts.fieldName
			fieldConfig.name = fieldName

			if (fieldConfig.aliasName) {
				config.fieldAliasMap[fieldConfig.aliasName] = fieldName
			}
		}

		// SINGLE FIELD UPDATE
		if (isNamePassed) {
			set(name, configData, configOpts.replace)
		}
		// SINGLE -OR- MULTIPLE FIELDS, AS A HASH...
		else if (isPlainObject(configData)) {
			const singleFieldName = configData.name || configOpts.fieldName

			// SINGLE FIELD UPDATE
			if (singleFieldName && isString(singleFieldName)) {
				set(singleFieldName, configData, configOpts.replace)
			}
			// MULTIPLE FIELD UPDATE (keyed by fieldname)
			else {
				forOwn(configData, ( cfg, n ) => {
					set(n, cfg, true)
				})
			}
		}
		// MULTIPLE FIELD UPDATE - CONFIGS AS ARRAY
		// (requires a 'name' key inside each config hash)
		else if (isArray(configData)) {
			for (const cfg of configData) {
				if (isPlainObject(cfg)) {
					set(cfg.name, cfg, true)
				}
			}
		}

		internal.triggerComponentUpdate()

		return formManager
	}


	/**
	 * Set field-config for one or more fields
	 * Accepts an array -or- hash keyed by fieldname to set multiple fields.
	 *
	 * @param {Object} [settings]
	 * @returns {Object}            All SETTERS return instance for chaining
	 */
	function setFieldDefaults( settings ) {
		merge(config.fieldDefaults, settings)

		internal.triggerComponentUpdate()

		return formManager
	}


	/**
	 * PUBLIC GETTER for field validation options
	 *
	 * @public
	 * @param {string} name     Fieldname to get
	 * @returns {Object}        Validation-config in getter mode
	 */
	function getFieldValidation( name ) {
		return cloneDeep(getField(name, 'validation'))
	}

	/**
	 * PUBLIC SETTER for field validation options
	 *
	 * @public
	 * @param {string} name             Fieldname to get/set
	 * @param {Object} [settings]       New Validation setting(s)
	 * @param {Object} [opts]            Option for merging with existing config
	 * @returns {Object}                All SETTERS return instance for chaining
	 */
	function setFieldValidation( name, settings, opts = { merge: false } ) {
		const newSettings = cloneDeep(settings)
		return setField(name, 'validation', newSettings, opts)
	}


	/**
	 * PUBLIC GETTER for 'validation.required' flag.
	 *
	 * @public
	 * @param {(string|Array)} name    Fieldname (or array of), for mass update
	 * @returns {(boolean|Object)}     Returns true/false OR a hash of values
	 */
	function isFieldRequired( name ) {
		return getField(name, 'validation.required') || false
	}

	/**
	 * PUBLIC SETTER for validation 'required' flag.
	 *
	 * @public
	 * @param {(Array|string)} name     Fieldname (or array of), for mass update
	 * @param {boolean} required        Set this field(s) required?
	 * @returns {Object}                All SETTERS return instance for chaining
	 */
	function setFieldRequired( name, required = true ) {
		return setField(name, 'validation.required', !!required)
	}


	/**
	 * PUBLIC GETTER for field.disabled flag.
	 *
	 * @public
	 * @param {(string|Array)} name    Fieldname (or array of), for mass update
	 * @returns {(boolean|Object)}     Returns true/false OR a hash of values
	 */
	function isFieldDisabled( name ) {
		const disabled = getField(name, 'disabled')
		return disabled || config.fieldDefaults.disabled || false
	}

	/**
	 * PUBLIC SETTER for field.disabled flag.
	 * Setting 'false' means REMOVE the disabled flag so will use fieldDefaults
	 *
	 * @public
	 * @param {(Array|string)} name    Fieldname (or array of), for mass update
	 * @param {boolean} disabled       Set this field disabled?
	 * @returns {Object}               All SETTERS return instance for chaining
	 */
	function setFieldDisabled( name, disabled = true ) {
		return setField(name, 'disabled', !!disabled || undefined)
	}

	/**
	 * PUBLIC SETTER for fieldDefaults.disabled flag.
	 *
	 * @public
	 * @param {boolean} disabled    	Set all fields disabled?
	 * @returns {Object}          		All SETTERS return instance for chaining
	 */
	function setDefaultDisabled( disabled = true ) {
		return setFieldDefaults({ disabled: !!disabled })
	}


	/**
	 * PUBLIC GETTER for field.readOnly flag.
	 *
	 * @public
	 * @param {(Array|string)} name    Fieldname (or array of), for mass update
	 * @returns {(boolean|Object)}     Returns true/false OR a hash of values
	 */
	function isFieldReadOnly( name ) {
		const readOnly = getField(name, 'readOnly')
		return readOnly || config.fieldDefaults.readOnly || false
	}

	/**
	 * PUBLIC SETTER for field.readOnly flag.
	 * Setting 'false' means REMOVE the readOnly flag so will use fieldDefaults
	 *
	 * @public
	 * @param {(Array|string)} name    	Fieldname (or array of), for mass update
	 * @param {boolean} readOnly    	Set this field disabled?
	 * @returns {Object}            	All SETTERS return instance for chaining
	 */
	function setFieldReadOnly( name, readOnly = true ) {
		return setField(name, 'readOnly', !!readOnly || undefined)
	}

	/**
	 * PUBLIC SETTER for fieldDefaults.readOnly flag.
	 *
	 * @public
	 * @param {boolean} readOnly    	Set all fields disabled?
	 * @returns {Object}            	All SETTERS return instance for chaining
	 */
	function setDefaultReadOnly( readOnly = true ) {
		return setFieldDefaults({ readOnly: !!readOnly })
	}


	/**
	 * Helper for getting field config values
	 *
	 * @param {string} name        	Fieldname - may be an alias
	 * @param {string} branch    	Path inside field-config to return
	 * @returns {(Object|*)} 		ONE Field-config-value for a field(s)
	 */
	function getField( name, branch ) {
		const get = n => {
			const fieldName = aliasToRealName(n)
			const path = `fields.${fieldName}.${branch}`
			return getObjectValue(config, path)
		}

		return isArray(name)
			// Return an object with passed names as the keys
			? name.reduce(( obj, n ) => { obj[n] = get(n); return obj }, {})
			: get(name)
	}

	/**
	 * Helper for setting field config values
	 *
	 * @param {string} name         Fieldname - may be an alias
	 * @param {string} branch       Path inside field-config to return
	 * @param {*} value            	Value to be set
	 * @param {Object} [opts]       Options to pass to setObjectValue()
	 * @returns {Object}       		All SETTERS return instance for chaining
	 */
	function setField( name, branch, value, opts = {} ) {
		let somethingChanged = false

		const set = n => {
			const fieldName = aliasToRealName(n)
			// Must use array because fieldName may contain dots (nested field)
			const path = ['fields', fieldName, branch]
			const oldValue = getObjectValue(config, path)

			if (value !== oldValue) {
				setObjectValue(config, path, value, opts)
				somethingChanged = true
			}
		}

		if (isArray(name)) {
			for (const n of name) set(n)
		}
		else {
			set(name)
		}

		if (somethingChanged) {
			internal.triggerComponentUpdate()
		}

		return formManager
	}


	/**
	 * Helper to convert aliasName to fieldName
	 * @param name            The name OR aliasName of a field
	 * @returns {string}    If alias found then mapped fieldName, else name
	 */
	function aliasToRealName( name ) {
		if (!name) return name
		if (isArray(name)) return name.map(aliasToRealName)

		if (config.fields[name]) return name

		const realName = config.fieldAliasMap[name]
		if (config.fields[realName]) return realName

		// field nay not have a field-configuration, so can't find the name
		return name
	}


	/**
	 * Helper that looks for EITHER A field-specific OR default config option
	 * @param {Object} fieldConfig
	 * @param {string} path
	 * @returns {undefined|*}
	 */
	function withFieldDefaults( fieldConfig, path ) {
		// If field specifies a value, use it!
		const fieldConfigValue = getObjectValue(fieldConfig, path)
		if (!isNil(fieldConfigValue)) return fieldConfigValue

		const defaultValue = getObjectValue(config.fieldDefaults, path)
		if (!isNil(defaultValue)) return defaultValue

		return undefined
	}
}

// noinspection JSUnusedGlobalSymbols
export default Config
